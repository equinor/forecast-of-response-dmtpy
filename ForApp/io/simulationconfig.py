# This an autogenerated file
# 
# Generated with SimulationConfig
from dmt.entity import Entity
from dmt.blueprint import Blueprint
from .blueprints.simulationconfig import SimulationConfigBlueprint
from typing import Dict,Sequence,List,Optional, Union
from ForApp.io.variable import Variable
from ForApp.io.simulation import Simulation
from ForApp.io.variablerun import VariableRun
import copy, itertools

class SimulationConfig(Entity):
    """
    
    
    Keyword arguments
    -----------------
    name : str 
         (default "")
    description : str 
         (default "")
    variables : List[Variable] 
         
    simulations : List[Simulation] 
         
    published : bool 
         (default False)
    """

    def __init__(
        self , name:str="", description:str="", 
        variables:List[Variable]=None, simulations:List[Simulation]=None,
        published:bool=False, **kwargs):
        self.__name = name
        self.__description = description
        self.__variables = list() if variables is None else variables
        self.__simulations = list() if simulations is None else simulations
        self.__published = published
        for key, value in kwargs.items():
            if not isinstance(value, Dict):
                setattr(self, key, value)


    @property
    def blueprint(self) -> Blueprint:
        """Return blueprint that this entity represents"""
        return SimulationConfigBlueprint()


    @property
    def name(self) -> str:
        """"""
        return self.__name

    @name.setter
    def name(self, value: str):
        """Set name"""
        self.__name = str(value)

    @property
    def description(self) -> str:
        """"""
        return self.__description

    @description.setter
    def description(self, value: str):
        """Set description"""
        self.__description = str(value)

    @property
    def variables(self) -> List[Variable]:
        """"""
        return self.__variables

    @variables.setter
    def variables(self, value: List[Variable]):
        """Set variables"""
        if not isinstance(value, Sequence):
            raise Exception("Expected sequense, but was " , type(value))
        self.__variables = value

    @property
    def simulations(self) -> List[Simulation]:
        """"""
        return self.__simulations

    @simulations.setter
    def simulations(self, value: List[Simulation]):
        """Set simulations"""
        if not isinstance(value, Sequence):
            raise Exception("Expected sequense, but was " , type(value))
        self.__simulations = value

    @property
    def published(self) -> bool:
        """"""
        return self.__published

    @published.setter
    def published(self, value: bool):
        """Set published"""
        self.__published = bool(value)

    @staticmethod
    def _str2bool(v): return v.lower() in ("yes", "true", "t", "1") or v.lower() in "true"

    def get(self, name:Optional[str]=None, delimiter:str=';') -> Union[List[VariableRun],str]:
        """Reads the variables on the simulationconfig and checks if the value of 
        the variable is an array of values delimited by ';' (default). The delimiter should
        correspond to the value used in the forecast of response front end.
        
        For all permutations of variables the function returns a list of type 
        VariableRun. If a specific variable is known to be unchanged between variableruns, 
        the variable name can be specified to return just the value of that variable

        Args:
            name (Optional[str], optional): variable name. Defaults to None.
            delimiter (str, optional): delimiter for value arrays. Defaults to ';'.

        Returns:
            Union[List[VariableRun],str]: [description]
            
        TODO: compile functionality for comparisonGroups / bar-plots e.g. "heading variation plots"
                    
        """
        cast = {'string':str, 'number':float, 'integer':int, 'bool': self._str2bool}
        iterables, variableRuns = [], []
        iterable_names = []
        for variable in self.variables:
            iterables.append([cast[variable.valueType](var) for var in variable.value.split(delimiter)])
            # Add some default functionality for naming the variableRun based on variations/arrays
            if delimiter in variable.value:
                iterable_names.append([f"{variable.name}: {var} {variable.unit}" for var in variable.value.split(delimiter)]) 
            
        for ivar, variable_values in enumerate(itertools.product(*iterables)):       
            variables = copy.deepcopy(self.variables)
            for variable, value in zip(variables, variable_values):
                variable.value = value # should perhaps keep as str?
            variableRuns.append(
                VariableRun(
                    name=f"forecast",
                    variables=variables
                )    
            )
        
        # Add some default functionality for naming the variableRun based on variations/arrays
        for ivar, variable_names in enumerate(itertools.product(*iterable_names)):    
            variableRun_name = "forecast [" + ', '.join(variable_names) + "]"
            variableRuns[ivar].name = variableRun_name
            
        if name is None: return variableRuns
        else: return [variable.value for variable in variableRuns[0].variables 
                            if variable.name == name][0]
    
    
        